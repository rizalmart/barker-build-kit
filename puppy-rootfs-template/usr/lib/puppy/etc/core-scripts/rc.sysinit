#!/bin/ash
#(c) copyright Barry Kauler 2008, puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
# see also initNEW -> /sbin/init, init (initramfs), rc.shutdown.
#
# How rc.sysinit is triggered:
# - /sbin/init executes busybox init or minit
# - busybox init is controlled by /etc/inittab
#   /etc/inittab: rc.sysinit is specified as ::sysinit:
# - also read /etc/inittab.README
#
# eudev is enforced - min 204+ recommended
#
#w004 LANG=C, faster. /bin/ash, even faster.
#w481 fix crappy depmod, 'out of memory' in first boot 64MB RAM (no swap).
#v424 fix secondary uevent replay. now finds ssb devices.
#100131 bugfix detect multiple cd/dvd drives.
#100703 load fbcon module: needed by some xorg drivers when exit to console (ex: nouveau).
#100814 record cumulative tx/rx, see also network_tray and rc.shutdown.
#101119 /sbin/pup_event_backend_modprobe has been rewritten, repercussions here.
#101210 new path /tmp/pup_event_backend for files logged by /sbin/pup_event_backend_*.
#110405 fix 'free' applet output format different in later versions of busybox.
#110426 move done/failed/backgrounded 2 places to right (also in init script).
#110502 fix creation of owner:group for device nodes. 110503 fix permission fsckme.flg.
#110511 2nd uevent replay: now using udevadm for usb, ssb and pcmcia.
#110513 rcrsn51: udevadm usb replay fix, properly detect scanners etc.
#110712 fixes for kernel with usb core (including usb-storage) drivers builtin.
#110814 kernel with inbuilt usb drivers, usbfs was not mounting on /proc/bus/usb.
#120217 improvement for full hd install, non-english.
#120301 need to load console font earlier.
#120301 a problem if initrd has kernel default font, switching here changes all o/p from initrd to partial garbage.
#120313 fix 120301 font garbage. 120331 clear requires redirection to /dev/console.
#120423 pemasu: /dev/mouse was missing in full install.
#120503 if kernel mounts a f.s. on /dev, removes my skeleton /dev
#120709 BOOT_UDEVDCHILDREN from /etc/rc.d/BOOTCONSTRAINED
#130311 use modinfo to test if fbcon builtin.
#130504 moved up, i think fbcon needs to be loaded before intel, nouveau modules load.
#160609 rerwin: Add wait for USB3 driver.

export INIT_ARGS="$1"

case $INIT_ARGS in

 sysvinit)

	 export SYSVINIT_MODE="$2"	
	  
	 SYSVINIT_RUNLEVEL="$3"
	 
	 [ "$SYSVINIT_RUNLEVEL" == "" ] && SYSVINIT_RUNLEVEL=$(who -r | awk '{print $2}')

	 export SYSVINIT_RUNLEVEL
	 
	 export BOOT_MODE="sysvinit"
    
      if [ "$SYSVINIT_MODE" == "slackware" ]; then
		
		 if [ "$SYSVINIT_RUNLEVEL" == "S" ]; then
		 
		    export SYSINIT_SETUP="y"
			export BLOCK_DEV_MOUNT="y"
			export RUN_UDEV="y"
			export RUN_SERVICES="y"
			export SETUP_TMPFS="y"
			export LOAD_SYSCONFIG="y"
			export SETUP_LOCALE="y"
			export SHOW_LOGIN_PROMPT="y"
			
			export TTY_OUTPUT=/dev/console
		 
		 else
		   	export RUN_RC="y"
		 fi
	  
	  else
	    [ "$SYSVINIT_RUNLEVEL" == "S" ] && export SYSINIT_SETUP="y" 
	    export RUN_RC="y"			
	  fi

	  
	 
 ;;
 systemd|basic|*)
	 export BOOT_MODE="$INIT_ARGS"
	 export TTY_OUTPUT=/dev/null
 ;; 
esac
 
export LANG=C

export HOME="/root"

export PATH="/usr/lib/puppy/bin:/usr/lib/puppy/sbin:/usr/bin/overrides:/usr/sbin/overrides:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/usr/bin/32:/usr/sbin/32:/usr/games:/root/my-applications/bin"

#if [ "$LD_LIBRARY_PATH" == "" ]; then

	LD_LIBRARY_PATH32="/usr/local/lib32:/usr/local/libx32:/usr/local/lib/i386-linux-gnu:/usr/local/lib:/usr/lib32:/usr/libx32:/usr/lib/i386-linux-gnu:/usr/lib:/lib32:/libx32:/lib/i386-linux-gnu:/lib:/root/my-applications/lib"
	LD_LIBRARY_PATH64="/usr/local/lib64:/usr/local/lib/x86_64-linux-gnu:/usr/local/lib:/usr/lib64:/usr/lib/x86_64-linux-gnu:/usr/lib:/lib64:/lib/x86_64-linux-gnu:/lib:/root/my-applications/lib"
	LD_LIBRARY_PATH64_COMPAT="/usr/local/lib32:/usr/local/libx32:/usr/local/lib/i386-linux-gnu:/usr/lib32:/usr/libx32:/usr/lib/i386-linux-gnu:/lib32:/libx32:/lib/i386-linux-gnu"
		
	if [ -e /lib64/libc.so.6 ] || [ -e /lib/x86_64-linux-gnu/libc.so.6 ]; then #slackware64
		LD_LIBRARY_PATH="${LD_LIBRARY_PATH64}:${LD_LIBRARY_PATH64_COMPAT}"
	elif [ -e /libx32/libc.so.6 ] || [ -e /lib32/libc.so.6 ] || [ -e /lib/i386-linux-gnu/libc.so.6 ]; then #32-bit
		LD_LIBRARY_PATH="${LD_LIBRARY_PATH32}"
	else
	  if [ "$(uname -m | grep "64")" != "" ]; then
	   LD_LIBRARY_PATH="${LD_LIBRARY_PATH64}:${LD_LIBRARY_PATH64_COMPAT}"
	  else
	   LD_LIBRARY_PATH="${LD_LIBRARY_PATH32}"
	  fi
	fi
	
	LD_LIBRARY_PATH="/usr/lib/overrides:${LD_LIBRARY_PATH}"
	
	export LD_LIBRARY_PATH

#fi

. /usr/lib/puppy/etc/core-scripts/functions_x

KERNVER="`uname -r`"

export INITRD_FLD="/initrd"

[ -L /initrd ] && export INITRD_FLD=$(readlink /initrd 2>/dev/null)

#================================================================
#              functions used by the script
#================================================================

status_func() {
	
 local cols=$(stty size 2>/dev/null | awk '{print $2}')	
 
 if [ $1 -eq 0 ];then
	local word="done"
	local col=$((cols - ${#word} + 1))
	echo -en "\033[${col}G\033[1;32m${word}\033[0;39m\n" >$TTY_OUTPUT
 else
	local word="failed"
	local col=$((cols - ${#word} + 1))
	echo -en "\033[${col}G\033[1;31m${word}\033[0;39m\n" >$TTY_OUTPUT
    STATUS=0
 fi
 
 return $1 #return with same status as entry param.
}

create_zram_swap() {
	
  modprobe zram >/dev/null 2>&1
  
  RAM=`awk '/MemTotal/{print $2}' /proc/meminfo`
  
  echo ${RAM}000 > /sys/block/zram0/disksize || return 1
  mkswap /dev/zram0 || return 1
  swapon /dev/zram0

}

loadswap_func() { #w481 made into a function.
	
 echo "LOAD SWAP"
 
 #load a swap partition...
 for i in `probepart -no-optical | grep '|swap|'`
 do
  ONESWAP=`echo "$i" | cut -f 1 -d '|'`
  SWAPSIZEBYTES=`echo "$i" | cut -f 3 -d '|'`
  SWAPSIZEBYTES=$((SWAPSIZEBYTES * 512 )) #bytes
 
  [ $SWAPSIZEBYTES ] && EXTRAALLOCK=$(($EXTRAALLOCK + $SWAPSIZEBYTES))
  
  ECHO_ARGS=""
  
  [ "$SYSINIT_SETUP" != "" ] && ECHO_ARGS="-n"
  
  echo $ECHO_ARGS "Loading swap partition $ONESWAP ("$(fx_format_bytes $SWAPSIZEBYTES)")..." >/dev/console #loading swap partition
  
  chmod 0660 $ONESWAP
  
  swapon $ONESWAP
  
  [ "$SYSINIT_SETUP" != "" ] && status_func $?
  
  [ $? -eq 0 ] && SWAPON="yes"
  
 done
 
 [ "$SWAPON" = "yes" ] && return
 
 #if no go, try for a swap file...
 if [ -f ${INITRD_FLD}${PUP_HOME}/pupswap.swp ] ; then
   SWAPFILE="${INITRD_FLD}${PUP_HOME}/pupswap.swp"
 elif [ -f /pupswap.swp ] ; then
   SWAPFILE="/pupswap.swp"
 fi
 
 if [ "${SWAPFILE}" ] ; then
  SWAPSIZEBYTES=`stat -c %s ${SWAPFILE}` #bytes
 
  echo -n "Loading swap file ${SWAPFILE} ("$(fx_format_bytes $SWAPSIZEBYTES)")..." >/dev/console
  chmod 0660 $SWAPFILE
  swapon ${SWAPFILE} ; ret=$? ; status_func $ret
 
  if [ $ret -eq 0 ] ; then
    [ "$SWAPSIZEBYTES" ] && EXTRAALLOCK=$(($EXTRAALLOCK + $SWAPSIZEBYTES))
    SWAPON="yes"
    return
  fi
 
 fi
 
 # if we failed to find a swap partition or file, try zram
 
 if [ "$(swapon --show | grep "/dev/zram")" == "" ]; then
     
     if [ "$BOOT_MODE" != "systemd" ]; then
     
		 echo -n "Loading zram swap ..." >/dev/console
		 create_zram_swap
		 ret=$?
		 
		 status_func $ret
 
	 fi
 
 fi
 
 [ $ret -eq 0 ] && SWAPON="yes"
 
}

start_lvm(){

  # Create LVM lock/run directories:
  mkdir -p -m 0700 /run/lvm /run/lock /run/lock/lvm
  
  if [ -r /etc/lvmtab -o -d /etc/lvm/backup ]; then
    
    echo "Initializing LVM (Logical Volume Manager):"
    
    # Check for device-mapper support.
    if ! grep -wq device-mapper /proc/devices ; then
      # Try to load a device-mapper kernel module:
      modprobe -q dm-mod
    fi
    
    # Scan for new volume groups:
    vgscan --mknodes --ignorelockingfailure 2> /dev/null
    
    if [ $? = 0 ]; then
    
      # Make volume groups available to the kernel.
      # This should also make logical volumes available.
      vgchange -ay --ignorelockingfailure
    
    fi
  fi	

	
}

build_sw_raid(){
 if [ "$(mdadm --examine --scan)" != "" ]; then	
	[ -e /etc/mdadm.conf ] && mdadm --assemble --scan
 fi
}

mount_cgroups(){
	
# Mount Control Groups filesystem interface:
if grep -wq cgroup /proc/filesystems ; then

    if [ -d /sys/fs/cgroup ]; then

        # See linux-*/Documentation/admin-guide/cgroup-v1/cgroups.rst (section 1.6)
        # Check if we have some tools to autodetect the available cgroup controllers
        # Mount a tmpfs as the cgroup filesystem root
        mount -t tmpfs -o mode=0755,size=8M cgroup_root /sys/fs/cgroup
    
        # Autodetect available controllers and mount them in subfolders
        controllers="$(cut -f 1 /proc/cgroups | tail -n +2)"
       
        for i in $controllers
        do
          mkdir /sys/fs/cgroup/$i
          mount -t cgroup -o $i $i /sys/fs/cgroup/$i
        done
       
        unset i controllers

    else
      mkdir -p /dev/cgroup
      mount -t cgroup cgroup /dev/cgroup
    fi
    
fi	
	
	
}

mount_efivars(){

# The efivarfs filesystem is used for reading and writing EFI variables, such
# as the boot menu entries. By default efivarfs will be mounted read-write on
# the /sys/firmware/efi/efivars directory. To modify this behavior, edit the
# file: /etc/default/efivarfs
# Only try to mount if this directory exists (so the kernel supports efivarfs):
if [ -d /sys/firmware/efi/efivars ]; then

  # Only try to mount if efivarfs is not already mounted:
  if ! mount | grep -wq efivarfs ; then

    # Mount according to /etc/default/efivarfs:
    if [ -r /etc/default/efivarfs ]; then
      . /etc/default/efivarfs
    else # default
      EFIVARFS=rw
    fi

    case "$EFIVARFS" in
      'rw')
      mount -o rw -t efivarfs none /sys/firmware/efi/efivars
      ;;
      'ro')
      mount -o ro -t efivarfs none /sys/firmware/efi/efivars
      ;;
    esac

  fi

fi	
	
}

mount_tmpfs(){

	 . /etc/rc.d/PUPSTATE

	FREERAM=`free | grep -o 'Mem: .*' | tr -s ' ' | cut -f 4 -d ' '` #w481 110405
	QTRFREERAM=`expr $FREERAM \/ 4`	
		
	[ $PUPMODE -eq 2 ] && busybox mount -t tmpfs -o size=${QTRFREERAM}k tmpfs /tmp

	##v2.20 some apps need shm (shared memory) (ex: xfdiff)... 100319 do this always...
	mkdir -p /dev/shm #120503 if kernel mounts a f.s. on /dev, removes my skeleton /dev
	busybox mount -t tmpfs -o size=${QTRFREERAM}k shmfs /dev/shm
	
}

check_xorg(){
	
	XORG_FOUND=""

	if [ -e /etc/desktop-session ]; then
	
	  . /etc/desktop-session
	  
	  if [ "$DESKTOP_SESSION" == "x11" ] || [ "$DESKTOP_SESSION" == "xorg" ]; then
		XORG_FOUND="y"
	  fi
	  
	else
	 [ "$(which X Xorg)" != "" ] & XORG_FOUND="y"
	fi


	if [ "$XORG_FOUND" != "" ]; then
	
		### /var/local/xorg_udev is created when:
		### - a touchscreen has been detected
		### - missing xorg input-kbd and input-mouse drivers [ex: ubuntu xenial]
		#TOUCHMOD=`lsmod | grep touch`
		ISITANXO=`cat /sys/class/dmi/id/product_name` #mavrothal: Check if it is an OLPC XO
		ISITAMAC=`grep -i -m 1 '^apple' /sys/class/dmi/id/board_vendor`

		[ -f /lib64/libc.so.6 ] && lsuffix=64 || lsuffix= #slackware64

		if [ ! -f /usr/lib${lsuffix}/xorg/modules/input/kbd_drv.so -a ! -f /usr/lib${lsuffix}/xorg/modules/input/mouse_drv.so ] ; then
		  echo "XORG_UDEV=1: Xorg kbd_drv.so and mouse_drv.so are missing"
		  XORG_UDEV=1
		fi

		TOUCHSCREEN="$(udevadm info --export-db | grep -m 1 ID_INPUT_TOUCHSCREEN=1)"

		if [ -n "$TOUCHSCREEN" ] ; then
		  echo "Touchscreen detected: $TOUCHSCREEN"
		  XORG_UDEV=1
		fi

		if [ -n "$ISITAMAC" ] ; then
		  echo "MAC detected: $ISITAMAC"
		  XORG_UDEV=1
		fi

		case $(uname -m) in arm*|aarch*) XORG_UDEV=1 ;; esac

		if [ "$XORG_UDEV" = '1' ] ; then
		  echo "Activating Xorg Evdev"
		  [ ! -f /var/local/xorg_udev ] && rm -fv /etc/X11/xorg.conf #force xorgwizard-automatic
		  touch /var/local/xorg_udev
		else
		  echo "Deactivating Xorg Evdev"
		  [ -f /var/local/xorg_udev ] && rm -fv /etc/X11/xorg.conf #force xorgwizard-automatic
		  rm -fv /var/local/xorg_udev
		fi
		
		
		## process some specific kernel params here
		for i in $(cat /proc/cmdline) ; do
			case $i in
				inteluxa|intel_uxa|uxa) xorg_intel_uxa.sh ;;
				xerrs)   rm -f /var/local/xwin_disable_xerrs_log_flag ;; # see xwin / bootmanager
				noxerrs) touch /var/local/xwin_disable_xerrs_log_flag ;; # see xwin / bootmanager
				pfix=*)

					pfix=${i#pfix=} #remove pfix=

					for ONEFIX in ${pfix//,/ } ; do
						case $ONEFIX in
							xorgwizard) /tmp/xwin_xorgwizard_cli ;; 
							nox)        /tmp/bootcnt.txt ;;
						esac
					done

					;;
			esac
		done

	fi

}

pupsave_io_fix(){

	KVER=$(uname -r)
	KMAJOR=$(echo "$KVER" | cut -f 1 -d '-' | cut -f 1 -d '.')
	KMINOR=$(echo "$KVER" | cut -f 1 -d '-' | cut -f 2 -d '.')

	# SFR hack for IO bug http://murga-linux.com/puppy/viewtopic.php?p=681383#681383
	if [ "$PUPMODE" != "5" ];then  
	  if [ $KMAJOR -ge 3 ] && [ $KMINOR -ge 2 ];then
		if [ $KMAJOR -le 3 ] && [ $KMINOR -lt 8 ]; then
		  case "$DEV1FS" in ntfs|ntfs3|vfat|ext2|exfat) # changed 130210, SFR
			busybox mount -o remount,sync /dev/loop1 ;;
		  esac
		fi
	  fi
	fi
	
}

mount_block_dev(){

[ ! -d /dev ] && mkdir /dev
[ ! -d /proc ] && mkdir /proc
[ ! -d /sys ] && mkdir /sys

# mount devtmpfs early
busybox mount -t devtmpfs devtmpfs /dev

# busybox mount /proc before remounting / as rw (full install)
busybox mount -t proc none /proc

busybox mount -t sysfs none /sys

#had hoped to retire this, but HardInfo, Pupscan need it... 110814 fix test...
[ -e /proc/bus/usb ] && busybox mount -t usbfs none /proc/bus/usb

#120503 if kernel mounts a f.s. on /dev, removes my skeleton /dev
mkdir -p /dev/pts
busybox mount -t devpts -o dev,suid,gid=2,mode=620 none /dev/pts	

mount -t binfmt_misc none /proc/sys/fs/binfmt_misc
	
}

prepare_block_devices(){

#130618 devtmpfs-enabled kernel, initrd may have loaded it on /dev
#device nodes created by kernel in initrd are all 'root' group.
#fix (before starting udevd)...

	chmod 666 /dev/* 2>/dev/null
	chmod 666 /dev/pts/* 2>/dev/null
	chown -R root:tty /dev/pts/
	chmod 666 /dev/null
	chmod 666 /dev/zero
	chmod 666 /dev/[pt]ty*
	chmod 666 /dev/ptmx
	chmod 777 /dev/pts/
	chgrp tty /dev/[pt]ty*
	chown -R root:tty /dev/pts/
	chown root:tty /dev/tty1
	chown root:tty /dev/ptmx
	chgrp tty /dev/console #bugfix 140617
	chgrp video /dev/fb0
	chgrp floppy /dev/fd[0-9] 2>/dev/null
	chgrp disk /dev/[hs]d[a-z]* 2>/dev/null
	chgrp disk /dev/fuse
	chgrp disk /dev/mmcblk* 2>/dev/null
	chgrp disk /dev/nvme* 2>/dev/null
	chgrp disk /dev/md* 2>/dev/null
	chgrp cdrom /dev/sr[0-9] 2>/dev/null
	chgrp cdrom /dev/scd[0-9] 2>/dev/null
	chmod 666 /dev/usb/* #rcrsn51 finally added 140618
	chmod -R 1777 /dev/shm #SFR .. ditto
	chmod 666 /dev/urandom #and again

	# Add any system/locally defined additional device nodes:
	cp --preserve=all --recursive --update /lib/udev/devices/* /dev 2> /dev/null
	cp --preserve=all --recursive --update /etc/udev/devices/* /dev 2> /dev/null
	# --

}	

start_udev(){
	
#rm -f /etc/init.d/udev #just in case
#rm -f /etc/init.d/rc.udev #just in case

# must create /sbin/udevd symlink if system-udevd is used
if [ ! -e /bin/udevd ] && [ ! -e /sbin/udevd ] ; then
  [ -f /lib/systemd/systemd-udevd ] && ln -snfv /lib/systemd/systemd-udevd /sbin/udevd
fi

#110502 change 'never' to 'early', fixes device nodes created with correct owner:group...
if [ "$BOOT_UDEVDCHILDREN" ];then #120709
   udevd --daemon --resolve-names=early --children-max=${BOOT_UDEVDCHILDREN} #BOOT_UDEVDCHILDREN=1 good idea?
else
   udevd --daemon --resolve-names=early
fi

sleep 0.3
	
}

run_runlevel_script(){
	
 rlevel="$1"
 
 if [ "$rlevel" != "" ]; then
  
	   find "/etc/rc${rlevel}.d" -maxdepth 1 \( -type f -o -type l \) | sort |
	   
	   while read -r script1
	   do 
		
		RUNLEVEL_CAN_RUN=""
		SCRIPT_BNAME="$(basename $script1)"
	   
		if [ "$script1" != "" ] && [ -x $script1 ]; then
		
		  if [ -L $script1 ]; then
			[ "$(readlink $script1 2>/dev/null | grep "/etc/init.d/")" == "" ] && RUNLEVEL_CAN_RUN="y"
		  elif [ -f $script1 ]; then
			RUNLEVEL_CAN_RUN="y"
		  fi  
		
		fi
		
		
		if [ "$RUNLEVEL_CAN_RUN" != "" ]; then
		   if [ "$(echo "$SCRIPT_BNAME" | grep "^K[0-9]*-" )" ]; then
			 $script1 stop
		   else
			 $script1 start
		   fi
		fi

	   done
   
 fi
 
	
}	

#================================================================
#                         MAIN
#================================================================

if [ "$BLOCK_DEV_MOUNT" != "" ]; then

	mount_block_dev

	mount_tmpfs

	mount_efivars

	mount_cgroups

fi

if [ "$BOOT_MODE" == "" ]; then

	INIT_BIN=$(readlink /proc/1/exe)

	[ -L $INIT_BIN ] && INIT_BIN=$(readlink $INIT_BIN)

	if [ "$(basename $INIT_BIN)" == "systemd" ]; then
	 export BOOT_MODE="systemd"
	else
	 export BOOT_MODE="sysvinit"
	fi

fi

export ROOT_FSTYPE="$(mount | grep " on / " | awk '{ print $5 }')"

echo -n "Making the filesystem usable..." > $TTY_OUTPUT

if [ "$LOAD_SYSCONFIG" != "" ]; then

	#Update microcode if possible
	if [ "$(uname -m | grep -E '^x86_64|^amd64|^i.86')" != "" ]; then

	 #Make sure that cpu is the physical cpu and microcode was not loaded early by boot parameter
	 if [ "$(grep -i -m 1 "hypervisor" /proc/cpuinfo)" == "" ] && [ "$(dmesg | grep -m 1 "microcode updated early")" == "" ]; then
	  if [ "$(which update-microcode)" != "" ]; then
	   echo -e "\n"
	   update-microcode
	  fi
	 fi

	fi

fi

. /etc/rc.d/PUPSTATE
. /etc/DISTRO_SPECS
. /etc/rc.d/BOOTCONSTRAINED # has BOOT_DISABLESWAP, BOOT_ATIME, BOOT_DIRTYWRITE.
. /etc/rc.d/MODULESCONFIG #modules loading configuration.

[ $loglevel ] && LOGLEVEL=$loglevel #boot param.
[ $pmedia ] && PMEDIA=$pmedia #boot parameter, broad category of boot media. ex: cd.
[ $pdev1 ] && PDEV1=$pdev1    #boot parameter, partition have booted off. ex: hda3

#if have just done a switch_root, output a 'done' message...
#[ $PUPMODE -ne 2 ] && status_func 0

if [ "$LOAD_SYSCONFIG" != "" ]; then

	ORIGLANG="`grep -m 1 '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`" #120217
	ORIGLANG1="${ORIGLANG%_*}" #ex: en

	#120301 a problem if initrd has kernel default font, switching here changes all o/p from initrd to partial garbage.
	#workaround, clear the screen...
	if [ $PUPMODE -ne 2 ] ; then #120313 fix...

	 PLANG1=`grep -m 1 '^PLANG=' /etc/rc.d/PUPSTATE | cut -f 2 -d '=' | cut -f 1 -d '_'`

	 [ ! "$PLANG1" ] && PLANG1='en'
	 [ "$ORIGLANG1" != "$PLANG1" ] && clear > /dev/console #120331 redirection is required.

	fi

	echo "Loading sysctl settings..."
	sysctl --system

	load_consolefont #120301 if this was done in initrd then it would carry through, and this would not be needed.
	#...this is done in rc.country, but needs to be move above all the o/p to /dev/console.

fi

pupsave_io_fix

STATUS=0

##############MAKE FILESYSTEM USABLE################

if [ "$BOOT_MODE" == "systemd" ]; then
	
	if [ "$(echo $ROOT_FSTYPE | grep -E "aufs|unionfs|overlay")" != "" ]; then
		
	   rm -f /etc/systemd/system/hibernate.target 2>/dev/null
	   rm -f /etc/systemd/system/hybrid-sleep.target 2>/dev/null	
		
	   ln -sf /lib/systemd/system/sleep.target /etc/systemd/system/hibernate.target 2>/dev/null
	   ln -sf /lib/systemd/system/sleep.target /etc/systemd/system/hybrid-sleep.target 2>/dev/null

	   PM_SUSPEND="$(which pm-suspend)"

	   if [ "$PM_SUSPEND" != "" ]; then

		   for pm_cmd in pm-hibernate pm-suspend-hybrid
		   do
		   
			   PM_BIN="$(which $pm_cmd)"
			   
			   if [ "$PM_BIN" != "" ]; then
			   
				   PM_DIR="$(dirname $PM_BIN)"
				   
				   [ -L $PM_BIN ] && PM_BIN="$(readlink $PM_BIN)"
					
				   if [ "$(basename $PM_BIN)" != "pm-suspend" ]; then
					  cp -f $PM_DIR/$pm_cmd $PM_DIR/${pm_cmd}.old
					  rm -f $PM_DIR/$pm_cmd
					  ln -s $PM_SUSPEND $PM_DIR/$pm_cmd
				   fi
			   
			   fi
			
		   done
		   
	   fi
	
	else
	
	   rm -f /etc/systemd/system/hibernate.target 2>/dev/null
	   rm -f /etc/systemd/system/hybrid-sleep.target 2>/dev/null
	   
	   PM_SUSPEND="$(which pm-suspend)"

	   if [ "$PM_SUSPEND" != "" ]; then

		   for pm_cmd in pm-hibernate pm-suspend-hybrid
		   do
		   
			   PM_BIN="$(which $pm_cmd)"
			   
			   if [ "$PM_BIN" != "" ]; then
			   
				   PM_DIR="$(dirname $PM_BIN)"
				   
				   [ -L $PM_BIN ] && PM_BIN="$(readlink $PM_BIN)"
					
				   if [ "$(basename $PM_BIN)" == "pm-suspend" ]; then
					  if [ -f $PM_DIR/${pm_cmd}.old ]; then	
					    rm -f $PM_DIR/$pm_cmd
						cp -f $PM_DIR/${pm_cmd}.old $PM_DIR/$pm_cmd
						rm -f $PM_DIR/${pm_cmd}.old
					  fi
				   fi
			   
			   fi
			
		   done
		   
	   fi	   
	   
	fi

fi

if [ "$SYSINIT_SETUP" != "" ]; then

	#=============== full-hd-install
	if [ $PUPMODE -eq 2 ] ; then
	 
	 #no longer deleting /tmp/* in rc.shutdown... (note, init script in initrd.gz wipes it)
	 rm -rf /tmp/*
	 rm -rf /tmp/.[0-9a-zA-Z]*
	 chmod 1777 /tmp 2>/dev/null
	 dmesg | grep -o 'EXT[2,3,4]-fs.*running e2fsck is recommended' > /tmp/dmesg_e2fsck_warnings1
	 
	 if grep -G "(${PDEV1})" /tmp/dmesg_e2fsck_warnings1 ; then
	 
	   #EXT3-fs (sda9): warning: mounting fs with errors, running e2fsck is recommended
	   #EXT3-fs (sda10): warning: maximal mount count reached, running e2fsck is recommended
	   echo > /tmp/bootsysinit_must_fsck
	 
	 fi
	 
	fi
	#===============

	rm -f /tmp/snd-kmod.lst 2>/dev/null

	[ -e /var/log/bootsysinit.log ] && rm -f /var/log/bootsysinit.log

	#redirect all output to a log file (must do after remount rw)...
	[ ! "$LOGLEVEL" ] && exec 1>/var/log/bootsysinit.log 2>&1

	#mount/umount scripts no longer write to /etc/mtab, as gparted failed to create a
	#gparted create ext3 part. failed, fixed by making /etc/mtab a symlink.
	rm -f /etc/mtab
	ln -sv /proc/mounts /etc/mtab

fi

if [ "$BLOCK_DEV_MOUNT" != "" ]; then

	build_sw_raid

	busybox mount -a #Load fstab entries

	start_lvm

fi

# kernel modules.builtin/order can also be found in /etc/modules
# if somehow they're missing from /lib/modules, they will be copied back

######################LOAD SWAP#####################

if [ "$SETUP_TMPFS" != "" ]; then

	[ "$BOOT_DISABLESWAP" != "" ] && SWAPON="$BOOT_DISABLESWAP" #120704 now ask in 3builddistro if want use swap file/partition. anything not "yes" means no.

	EXTRAALLOCK=0

	[ "$SWAPON" != "yes" ] && loadswap_func

	# we prefer not to use swap unless we have to; this should improve responsiveness if we don't have much RAM
	if [ "$SWAPON" == "yes" ]; then
	  echo 5 > /proc/sys/vm/swappiness
	  echo 50 > /proc/sys/vm/vfs_cache_pressure	
	fi


	if [ "$SWAPON" == "yes" ];then

	 # resize tmpfs
	 # this code is meant to increase the size of the tmpfs
	 # taking into account swap space and sfs_ram_sizek[might be removed]
	 EXTRAALLOCK=$(($EXTRAALLOCK / 2048)) #use half in KiB
	 RAMSIZE=$(free | grep -o 'Mem: .*' | tr -s ' ' | cut -f 2 -d ' ')
	 FREEK=$(($RAMSIZE / 2)) #half of physical.
	 ALLOCK=$(($FREEK + $EXTRAALLOCK))

	 if [ "$(grep -m 1 "${INITRD_FLD}/mnt/tmpfs" /proc/mounts)" != "" ];then #mounted
	  [ -s ${INITRD_FLD}/tmp/sfs_ram_sizek ] && ALLOCK=$(($ALLOCK + $(cat ${INITRD_FLD}/tmp/sfs_ram_sizek))) #proper size
	  busybox mount -t tmpfs -o remount,size=${ALLOCK}k tmpfs ${INITRD_FLD}/mnt/tmpfs
	 elif [ $PUPMODE -eq 2 ];then #full-install
	  busybox mount -t tmpfs -o remount,size=${ALLOCK}k tmpfs /tmp
	 fi

	fi

	[ -d /var/run ] && find /var/run -name '*.pid' -delete
	
elif [ "$BOOT_MODE" == "systemd" ];then

    loadswap_func
	echo 5 > /proc/sys/vm/swappiness
	echo 50 > /proc/sys/vm/vfs_cache_pressure
	
fi



status_func 0

#################LOAD KERNEL MODULES################

if [ "$SYSINIT_SETUP" != "" ]; then

	echo "LOAD KERNEL MODULES"
	echo -n "Loading kernel modules..." >/dev/console

	MODALIASES="`ls /sys/bus/*/devices/*/modalias`"

	#101119 new /sbin/pup_event_backend_modprobe, these must be deleted every boot...
	rm -f /etc/modprobe.d/alsa_card*.conf 2>/dev/null
	rm -f /dev/ttyUSB* 2>/dev/null #101210 may have been left there if modem plugged in at shutdown.
	rm -f /dev/mixer 2>/dev/null #see test in /etc/init.d/10alsa.
	rm -f /dev/snd/* #after a reboot, some of these may be wrong.
	mkdir /tmp/pup_event_backend #101210 for logging into, see /sbin/pup_event_backend_modprobe.

	#101119 no longer using /tmp/pup_event_modprobe.conf, put blacklist into /etc/modprobe.d/...
	rm -f /etc/modprobe.d/blacklist*.conf

	BLACKLISTVARS="`echo "$SKIPLIST" | tr '\-' '_' | tr ' ' '\n' | sed -e 's/^/blacklist /' | grep -v ' $'`"

	echo "$BLACKLISTVARS" > /etc/modprobe.d/blacklist.conf

	if [ $PUPMODE -eq 2 ] ; then #full hd install.

	 [ "`modinfo psmouse 2>/dev/null`" != "" ] && modprobe psmouse
	 #have this in 'init', probably need here too...

	 if [ "`echo "$MODALIASES" | grep -m 1 'bc0Csc03i10'`" != "" ];then
	  modprobe yenta-socket || sleep 2
	 fi

	 # k2.6.29.6 dmesg has warning that ehci-hcd should load before uhci-hcd and ohci-hid
	 [ "`lspci -n | grep -m 1 ' 0c03: '`" != "" ] && modprobe ehci-hcd > /dev/null 2>&1 #110712 maybe builtin to kernel.

	fi

	#130504 moved up, i think fbcon needs to be loaded before intel, nouveau modules load...
	#101119 i really only want to load this for a kms-enabled video...
	KMS=yes

	[ "`cat /etc/modprobe.d/* | grep -m 1 'nomodeset'`" != "" ] && KMS=no

	if [ "$KMS" == "yes" ]; then
		modprobe fbcon
		modprobe vesafb
		modprobe drm
	fi

	[ ! -d /proc/acpi ] && modprobe apm #load apm.ko if no acpi.
	[ ! -b /dev/ntsync ] && modprobe ntsync

	#only needed for 2.6.21.7, as 2.6.25.x loads these automatically...
	#explicitly load battery, ac, thermal, fan modules.
	modprobe battery
	
	if [ -f /proc/config.gz ]; then
		zcat /proc/config.gz | grep -m 1 -q '^CONFIG_INPUT_LEDS=m' && modprobe input-leds #for >= k4.2x
	fi

	ISITAMAC=`grep -i -m 1 '^apple' /sys/class/dmi/id/board_vendor`

	if [ -z "$ISITAMAC" ];then #don't run this block on mac
	 if [ -d /proc/acpi/battery ]; then
	 
	  results="`find /proc/acpi/battery -mindepth 1 -type d`"

	  if [ ! -z "$results" ]; then
	   modprobe ac
	   modprobe thermal
	   modprobe fan
	  else
	   rmmod battery
	  fi

	 fi
	fi


	if [ $PUPMODE -eq 2 ] ; then #full hd installation.
		 
		 for ONEMOD in fuse aufs overlay squashfs nls_cp437 nls_iso8859-1
		 do
			modprobe $ONEMODE 2>/dev/null	 
		 done
	 
		 # legacy stuff - should not be used in scripts
		   ALLDRVS0="`find /sys/block -maxdepth 1 -name 'mmc*' -o -name 'sd*' -o -name 'sr*' -o -name 'scd*' -o -name 'nvme*' -o -name 'md*' | xargs -l readlink 2>/dev/null | grep -v '/usb[0-9]' | rev | cut -f 1 -d '/' | rev`" #all *except* usb!
		   ATADRIVES="`echo "$ALLDRVS0" | grep -v '^sr' | tr '\n' ' '`"
		   ATAOPTICALDRIVES="`echo "$ALLDRVS0" | grep '^sr' | tr '\n' ' '`"
		   ATADRIVES=$(echo $ATADRIVES)
		   ATAOPTICALDRIVES=$(echo $ATAOPTICALDRIVES)
		   
		   (
		   echo '#ATADRIVES is all internal ide/pata/sata drives, excluding optical, excluding usb...'
		   echo "ATADRIVES='${ATADRIVES}'"
		   echo '#ATAOPTICALDRIVES is list of non-usb optical drives...'
		   echo "ATAOPTICALDRIVES='$ATAOPTICALDRIVES'"
		   ) >> /etc/rc.d/PUPSTATE

	fi

	status_func 0

fi


################WAIT MODULES LOADED##################

if [ "$SYSINIT_SETUP" != "" ]; then

	echo "WAIT MODULES LOADED"

	#previous module loading may not have completed...
	echo -n "Waiting for modules to complete loading..." >/dev/console
	PCMCIABUILTIN='no'

	if [ "`modinfo yenta_socket 2>/dev/null`" == "" ];then   #Marvmod shut this up.
	 #kernel has PCMCIA core drivers builtin.
	 PCMCIABUILTIN='yes'
	else
	  
	  WAITCNT=0
	  PCIPCMCIA="`lspci -n | grep -o ' 0607: '`"
	  
	  if [ "$PCIPCMCIA" != "" ];then   #this may be slow to respond.
	   
	   echo -n " pcmcia"  >/dev/console
	  
	   while [ $WAITCNT -lt 10 ]
	   do

		[ "`lsmod | grep -m 1 -E '^yenta_socket |^tcic |^i82092 |^i82365 |^pd6729 '`" != "" ] && break

		WAITCNT=`expr $WAITCNT + 1`

		sleep 1
		echo -n " $WAITCNT" >/dev/console

	   done
	  
	  fi
	fi

	#note, if initrd then usb-storage will have already loaded...
	USBBUILTIN='no'

	if [ "`modinfo ehci_hcd 2>/dev/null`" == "" ];then #110712 shut this up.
	 #kernel has usb core drivers (and usb-storage) builtin.
	 USBBUILTIN='yes'
	elif modinfo ehci_hcd | grep -m 1 -q '(builtin)' ;then #kmod new version
	 USBBUILTIN='yes' 
	else

	 PCIUSB="`lspci -n | grep -o -E ' 0c03: '`" #160609

	 if [ "$PCIUSB" != "" ];then #this may be slow to respond.

	  echo -n " usb"  >/dev/console

	  PCIUSBNUM=`echo "$PCIUSB" | sort -u | wc -l`

	  while [ $WAITCNT -lt 10 ]
	  do

	   [ `lsmod | grep -o -E '^uhci_hcd|^ohci_hcd|^ehci_hcd|^xhci_hcd' | wc -l` -ge $PCIUSBNUM ] && break #160609

	   WAITCNT=`expr $WAITCNT + 1`
	  
	   sleep 1
	   echo -n " $WAITCNT" >/dev/console
	  done

	 fi

	fi

	if [ "$USBBUILTIN" == "no" ];then #110712

	 #wait for usb-storage drives to become available...(already done if initrd)
	 #note, udevd logs to this file when load modules
	 # (the latter via udev handler script /sbin/pup_event_backend_modprobe)...
	 #101119 /tmp/pup_event_backend/pup_event_module_devpath_log* now multiple files (see /sbin/pup_event_backend_modprobe)
	 
	 if [ "`cat /tmp/pup_event_backend/pup_event_module_devpath_log* | grep -m 1 'usb_storage'`" != "" ];then #see pup_event_backend_modprobe
	  
	  echo -n " usb-storage"  >/dev/console
	  
	  while [ $WAITCNT -lt 15 ]
	  do

	   [ "`dmesg | grep -m 1 'usb-storage: device scan complete'`" != "" ] && break

	   sleep 1

	   WAITCNT=`expr $WAITCNT + 1`

	   echo -n " $WAITCNT" >/dev/console
	  done
	  
	  #precaution, make sure have got them all... need sort -u...
	  USBSTORAGES=`dmesg | grep -m 1 "usb-storage: device found at" | sort -u | wc -l`
	  
	  while [ $WAITCNT -lt 15 ]
	  do
	   AVAILABLEUSBSTORAGES=`dmesg | grep -m 1 "usb-storage: device scan complete" | wc -l`

	   [ $AVAILABLEUSBSTORAGES -ge $USBSTORAGES ] && break

	   sleep 1

	   WAITCNT=`expr $WAITCNT + 1`

	   echo -n " $WAITCNT" >/dev/console
	  done
	  
	 fi

	 sleep 1 #v411 a bit extra. rerwin reports usb mouse detection problem some hardware.
			 #(delay before usb mouse info appears in /proc/bus/input/devices)
	fi

	#modprobe snd-aloop
	#modprobe v4l2loopback-dc 2>/dev/null

	status_func 0

fi

##############USER SELECTED MODULES##################
echo "USER SELECTED MODULES"

#the user can select extra modules to load in the BootManager...
if [ "$ADDLIST" != "" ];then #variable is in /etc/rc.d/MODULESCONFIG

 echo -n "Loading user-selected modules..." >$TTY_OUTPUT

 for MODULE in $ADDLIST
 do

  MPARAMS=""

  if [ `echo -n "$MODULE" | tr ':' ' ' | wc -w` -gt 1 ];then
   MPARAMS="`echo -n "$MODULE" | cut -f 2-9 -d ':' | tr ':' ' '`"
   MODULE="`echo -n "$MODULE" | cut -f 1 -d ':'`"
  fi

  echo -n " $MODULE" >$TTY_OUTPUT
  echo "Loading module $MODULE $MPARAMS"
  modprobe $MODULE $MPARAMS

 done

 status_func 0
 
fi

if [ "$SYSINIT_SETUP" != "" ]; then

	echo "Creating static nodes in /dev ..."

	kmod static-nodes -f tmpfiles --output /run/static-nodes
	
	grep "^d " /run/static-nodes | while read line ; do
		mkdir -p -m $(echo $line | cut -f 3 -d ' ') $(echo $line | cut -f 2 -d ' ')
	done

	grep -v "^d " /run/static-nodes | while read line ; do

	mknod -m $(echo $line | cut -f 3 -d ' ') \
	$(echo $line | cut -f 2 -d ' ') \
	$(echo $line | cut -b1 ) \
	$(echo $line | cut -f 7 -d ' ' | cut -f 1 -d :) \
	$(echo $line | cut -f 7 -d ' ' | cut -f 2 -d :) 2> /dev/null

	done

	rm -f /run/static-nodes

	[ ! -e /dev/ppp ] && mknod /dev/ppp c 108 0
	
	prepare_block_devices

	[ -e /proc/sys/kernel/hotplug ] && echo "" > /proc/sys/kernel/hotplug
		
fi

##############UDEV########################

if [ "$RUN_UDEV" != "" ]; then
	
	start_udev
	
	if [ "$(pidof udevd)" != "" ]; then

		clear > /dev/console
		echo -n "Configuring hardware..." >/dev/console 

		udevadm trigger --type=subsystems --action=add
		udevadm trigger --type=devices --action=add

		#udevadm trigger --action=add --subsystem-match="input" --subsystem-match="sound" --subsystem-match="power_supply"
		udevadm settle -t 20
		
		status_func 0

	fi

fi

###########################################


#################MISC. SYSTEM SETUP#################
echo "MISC. SYSTEM SETUP"

if [ "$SYSINIT_SETUP" != "" ]; then

	[ -e /etc/isapnp.conf ] && isapnp /etc/isapnp.conf 2>/dev/null

	[ "$(which register-binfmt)" ] && register-binfmt

fi

if [ "$BOOT_DIRTYWRITE" ]; then #120704 see /etc/rc.d/BOOTCONSTRAINED, variable set in 3builddistro.

 #i have set this as 1500 which is 15 seconds (default is 5 seconds).
 echo $BOOT_DIRTYWRITE > /proc/sys/vm/dirty_writeback_centisecs #refer: http://www.lesswatts.org/tips/disks.php
 
fi

# kernel polling - https://lwn.net/Articles/423619/
echo 5000 > /sys/module/block/parameters/events_dfl_poll_msecs

# see https://www.frozentux.net/iptables-tutorial/other/ip_dynaddr.txt
# turn on special handling of dynamic addresses - quiet mode
echo "1" > /proc/sys/net/ipv4/ip_dynaddr

if [ "$BOOT_SCHEDULER" ];then #120704 see /etc/rc.d/BOOTCONSTRAINED, variable set in 3builddistro.

 #my kernel defaults to 'cfq', change to 'deadline'. refer: http://tombuntu.com/index.php/2008/09/04/four-tweaks-for-using-linux-with-solid-state-drives/
 if [ "$PDEV1" ];then

  PDEV="`echo -n "$PDEV1" | sed -e 's%[0-9]*$%%' -e 's%p$%%'`" #mmcblk0p2 becomes mmcblk0

  if [ "`grep -m 1 "$BOOT_SCHEDULER" /sys/block/${PDEV}/queue/scheduler`" != "" ];then #check available.
   if [ "`cat /sys/block/${PDEV}/queue/scheduler | cut -f 2 -d '[' | cut -f 1 -d ']' | grep -m 1 "$BOOT_SCHEDULER"`" = "" ];then #check not already chosen.
    echo $BOOT_SCHEDULER > /sys/block/${PDEV}/queue/scheduler
    echo 1 > /sys/block/${PDEV}/queue/iosched/fifo_batch
   fi
  fi

 fi

fi

##############platform adjustments################## see fd64's #rc.platform

if [ "$RUN_SERVICES" != "" ]; then

	###  - do it before we configure network and services
	# detect if it's MacBookPro (mavrothal)
	is_mbp="`dmesg | grep -i -m 1 macbookpro`"

	if [ "$is_mbp" ] ; then

		# enable gpe suppression and mbpfan
		chmod 755 /etc/init.d/z-disable-spurious-gpe

		[ -f /etc/init.d/15-mbpfan ] && chmod 755 /etc/init.d/15-mbpfan

	fi


	###################SETUP SERVICES################


		echo "SETUP SERVICES"
		echo -n "Setting up services (network, printing, etc.)..." >/dev/console

		if [ -h /dev/modem ];then
		 
		 DEVM="`readlink /dev/modem`"
		 
		 case $DEVM in
		  modem) #error, circular link.
		   rm -f /dev/modem
		   DEVM=""
		  ;;
		  /dev/*) #wrong format.
		   DEVM="`echo -n "$DEVM" | cut -f 3,4 -d '/'`"
		   ln -svnf $DEVM /dev/modem
		  ;;
		 esac

		 case $DEVM in
		 ttyS[0-9]) #apparently setserial can crash with other modems.
		   setserial -v -b /dev/modem auto_irq skip_test autoconfig
		  ;;
		 esac

		fi


		# dbus
		if which dbus-uuidgen >/dev/null 2>&1 ; then
			mkdir -p /var/lib/dbus /var/run/dbus
			rm -f /var/lib/dbus/machine-id /etc/machine-id
			chown messagebus /var/run/dbus
			chgrp messagebus /var/run/dbus
			dbus-uuidgen > /var/lib/dbus/machine-id
			ln -snf /var/lib/dbus/machine-id /etc/machine-id
			ln -snf /var/run/dbus /run/dbus
		fi


		if [ "$(pidof dbus-daemon)" == "" ]; then
		  dbus-uuidgen --ensure
		  dbus-daemon --system
		fi
	
	
		#start dbus-daemon
		if [ -e /etc/init.d/rc.messagebus ]; then
		  /etc/init.d/rc.messagebus start
		else
			if which dbus-daemon >/dev/null 2>&1 ; then
			 if [ "$(pidof dbus-daemon)" == "" ]; then
			  dbus-uuidgen --ensure
			  dbus-daemon --system
			 fi
			fi
		fi

		#----------------------
		
		 #sleep 5 # in some cases network modules take some time to load
		 
		 #100814 100903 record cumulative tx/rx, see also network_tray and rc.shutdown.
		 #181209 tx/rx logic now included in network_default_connect...
		 # Connect "current" or default network through eth0, frisbee, sns, network wizard, pgprs-connect, etc.
		
		networkconnect --sysinit & #181209
		
		#----------------------
		
		/usr/lib/puppy/etc/core-scripts/rc.services #run scripts in /etc/rc.d/init.d

		#----------------------
		
		#echo -e "\\033[${col}G\\033[1;33m${word}\\033[0;39m" >/dev/console #column 62, yellow. 110426: 64
		
		if [ "$SYSVINIT_RUNLEVEL" == "S" ] ; then
		
		   default_runlevel=$(grep '^id:.*:initdefault:' /etc/inittab | sed -E 's/^id:([0-9]):initdefault:.*/\1/')
		
		   [ "$default_runlevel" != "$SYSVINIT_RUNLEVEL" ] && run_runlevel_script $default_runlevel
		
		fi
		

		fcols=$(stty size 2>/dev/null | awk '{print $2}')	
		srvstat="[backgrounded]"
		xcol=$((fcols - ${#srvstat} + 1))	
		
		echo -e "\\033[${xcol}G\\033[1;33m[backgrounded]\\033[0;39m" >/dev/console #column 62, yellow. 110426: 64

fi


if [ "$RUN_RC" != "" ]; then

	    ### sysvinit rc scripts
	    if [ "$SYSVINIT_RUNLEVEL" != "0" ] && [ "$SYSVINIT_RUNLEVEL" != "6" ]; then
          run_runlevel_script $SYSVINIT_RUNLEVEL
		fi

fi



############RECOGNISE MEDIA DEVICES################

if [ "$SYSINIT_SETUP" != "" ]; then

	echo "RECOGNISE MEDIA DEVICES"

	STATUS=0

	echo -n "Recognising media devices..." >/dev/console
	echo -n ' optical' >/dev/console #optical drives

	CDTYPE=""
	DVDTYPE=""

	rm -f /dev/cdrom /dev/dvd /etc/cdburnerdevice 2>/dev/null

	if [ -e /dev/sr0 ] ; then
		ln -snfv /dev/sr0 /dev/cdrom
		ln -snfv /dev/sr0 /dev/dvd
	elif [ -e /dev/scd0 ] ; then
		ln -snfv /dev/scd0 /dev/cdrom
		ln -snfv /dev/scd0 /dev/dvd
	fi

	echo -n ' input' >/dev/console #input
	echo -n "input/mice" > /etc/mousedevice
	ln -snfv input/mice /dev/mouse


	#---- rc.country
	[ "$SETUP_LOCALE" != "" ] && /usr/lib/puppy/etc/core-scripts/rc.country &

	####

	###################PERSONAL BOOT SCRIPT######################
	echo "PERSONAL BOOT SCRIPT"

	#personal boot script here...
	if [ ! -f /etc/rc.d/rc.local ];then
	 echo '#this file called from rc.sysinit' > /etc/rc.d/rc.local
	 echo '#you can edit this file' >> /etc/rc.d/rc.local
	 echo '#When firewall is installed, will append lines to this file...' >> /etc/rc.d/rc.local
	fi

	. /etc/rc.d/rc.local 

fi

#improper shutdown check. see above, also rc.shutdown and /sbin/init...
if [ $PUPMODE -eq 2 ];then #full hd install.

 [ "`mount | grep -m 1 '^/dev/root ' | grep ' / '`" ] && ln -sfnv /dev/${PDEV1} /dev/root 2>/dev/null
 
 #this file gets removed by rc.shutdown if a proper shutdown...
 echo -n "${PDEV1},${DEV1FS}," > /fsckme.flg #ex: sda7,ext3,
 busybox chmod 666 /fsckme.flg #110503 so non-root can delete it.

else
 if [ "$PUPSAVE" -a $PUPMODE -ne 77 ];then # don't do this in a multi-session DVD (77)
  echo -n "$PUPSAVE" > ${INITRD_FLD}${PUP_HOME}/fsckme.flg #ex: sda7,ext3,/pupsave-10MAR2010.2fs
  busybox chmod 666 ${INITRD_FLD}${PUP_HOME}/fsckme.flg #110503 so non-root can delete it.
 fi
 
fi


if [ "$SYSINIT_SETUP" != "" ]; then

	for tmpfld in /tmp /run
	do

		for i in ${tmpfld}/runtime-* ; do
			[ -d ${i} ] || continue
			find ${i} -not -type d -delete
		done

	done
	


	if [ -e /etc/desktop-session ]; then

		pfix_value=$(cat /proc/cmdline | grep -oE 'psession=.*[ ]|psession=.*$' | xargs | cut -f 2 -d '=')
		
		if [ "$pfix_value" != "" ]; then
			
			. /etc/desktop-session
			
			if [ "$pfix_value" != "$DESKTOP_SESSION" ]; then
			
				if [ "$pfix_value"=="wayland" ]; then
				
				   sed -i -e "s#DESKTOP_SESSION=.*#DESKTOP_SESSION=wayland#g" /etc/desktop-session
				   
				   if [ -e /etc/lightdm/lightdm.conf ]; then
				     sed -i -e "s#autologin-session=.*#autologin-session=xfce-wayland#g" /etc/lightdm/lightdm.conf
				     sed -i -e "s#user-session=.*#user-session=xfce-wayland#g" /etc/lightdm/lightdm.conf
				   fi
				   
				else
				   
				   sed -i -e "s#DESKTOP_SESSION=.*#DESKTOP_SESSION=x11#g" /etc/desktop-session   
				
				   if [ -e /etc/lightdm/lightdm.conf ]; then
				     sed -i -e "s#autologin-session=.*#autologin-session=xfce#g" /etc/lightdm/lightdm.conf
				     sed -i -e "s#user-session=.*#user-session=xfce#g" /etc/lightdm/lightdm.conf
				   fi
				
				fi
			
			fi

		fi

	 
		. /etc/desktop-session
	 
		 if [ "$DESKTOP_SESSION" == "x11" ] || [ "$DESKTOP_SESSION" == "xorg" ]; then
		 
		  vid="$(busybox lspci | grep 'Class 030' | awk '{ print $4}' | cut -f 1 -d ':')"
		  
		  MAKE_XORG_CONF=""
		  
		  case $vid in
			8086|10de|1002|1022|15ad|1013|1b36|1234|1af4|80ee|1414)
			  MAKE_XORG_CONF=""  
			;;
					  
			*)
			
			  dvmw=$(cat /sys/class/dmi/id/product_name | head | xargs | grep -E "[Vv][Mm]ware")
			  dvbox=$(cat /sys/class/dmi/id/product_name | head | xargs | grep -E "[Vv]irtual[Bb]ox|vbox")	
			  
			  if [ "$dvmw" != "" ]; then
				MAKE_XORG_CONF="y"
			  elif [ "$dvbox" != "" ]; then
				MAKE_XORG_CONF="y"	        
			  fi	    
			
			;;
		  esac 
		 
		  [ "$MAKE_XORG_CONF" != "" ] && xorg-presetup
		 
		 fi
		 
	fi

	mkdir -p /var/local/shared
	chmod 775 /var/local/shared

fi

#ensure unique hostname: http://www.murga-linux.com/puppy/viewtopic.php?p=550932#550932
if [ "`cat /etc/hostname`" == "puppypc" ];then

 echo "Updating unique hostname..." >$TTY_OUTPUT #hostname
 echo "puppypc${RANDOM}" > /etc/hostname

 PUPHOSTNAME="`cat /etc/hostname`"
 HOSTSFILEFIRST="`grep -w 'puppypc' /etc/hosts|sed 's% puppypc%%'`"
 HOSTSFILEREST="`grep -v 'puppypc' /etc/hosts`"

 echo "127.0.0.1 $PUPHOSTNAME" > /etc/hosts
 echo "$HOSTSFILEREST" >> /etc/hosts

 status_func 0

fi


hostname -F /etc/hostname


if [ "$(grep "Linux $(uname -r) [$(uname -m) arch]" /etc/issue 2>/dev/null)" == "" ]; then
 echo "$DISTRO_NAME" > /etc/issue
 echo "Linux $(uname -r) [$(uname -m) arch]" >> /etc/issue
fi

if [ "$SHOW_LOGIN_PROMPT" != "" ]; then

	clear > /dev/console

	while read l ; do
		[ -z "$l" ] && continue
		echo "$l" > /dev/console
	done < /etc/issue

	exec &>/dev/console
	
fi

chmod 755 / 2>/dev/null

#that's it. next stop is /etc/profile...
###END###
